{
  "title": "Hash table",
  "slug": "hash-table",
  "extract": "In computer science, a hash table is a data structure that implements an associative array, also called a dictionary or simply map; an associative array is an abstract data type that maps keys to values. A hash table uses a hash function to compute an index, also called a hash code, into an array of buckets or slots, from which the desired value can be found. During lookup, the key is hashed and the resulting hash indicates where the corresponding value is stored. A map implemented by a hash table is called a hash map.\nMost hash table designs employ an imperfect hash function. Hash collisions, where the hash function generates the same index for more than one key, therefore typically must be accommodated in some way. Common strategies to handle hash collisions include chaining, which stores multiple elements in the same slot using linked lists, and open addressing, which searches for the next available slot according to a probing sequence.\nIn a well-dimensioned hash table, the average time complexity for each lookup is independent of the number of elements stored in the table. Many hash table designs also allow arbitrary insertions and deletions of key–value pairs, at amortized constant average cost per operation.\nHashing is an example of a space–time tradeoff. If memory is infinite, the entire key can be used directly as an index to locate its value with a single memory access. On the other hand, if infinite time is available, values can be stored without regard for their keys, and a binary search or linear search can be used to retrieve the element.\nIn many situations, hash tables turn out to be on average more efficient than search trees or any other table lookup structure. Hash tables are widely used in modern software systems for tasks such as database indexing, caching, and implementing associative arrays, due to their fast average-case performance. For this reason, they are widely used in many kinds of computer software, particularly for associative arrays, database indexing, caches, and sets. Many programming languages provide built-in hash table structures, such as Python’s dictionaries, Java’s HashMap, and C++’s unordered_map, which abstract the complexity of hashing from the programmer.\n\n\nHistory\nThe idea of hashing arose independently in different places. In January 1953, Hans Peter Luhn wrote an internal IBM memorandum that used hashing with chaining.  The first example of open addressing was proposed by A. D. Linh, building on Luhn's memorandum. Around the same time, Gene Amdahl, Elaine M. McGraw, Nathaniel Rochester, and Arthur Samuel of IBM Research implemented hashing for the IBM 701 assembler. Open addressing with linear probing is credited to Amdahl, although Andrey Ershov independently had the same idea. The term \"open addressing\" was coined by W. Wesley Peterson in his article which discusses the problem of search in large files.\nThe first published work on hashing with chaining is credited to Arnold Dumey, who discussed the idea of using remainder modulo a prime as a hash function. The word \"hashing\" was first published in an article by Robert Morris. A theoretical analysis of linear probing was submitted originally by Konheim and Weiss.\n\n\nOverview\nAn associative array stores a set of (key, value) pairs and allows insertion, deletion, and lookup (search), with the constraint of unique keys. In the hash table implementation of associative arrays, an array \n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n of length \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n is partially filled with \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n elements, where \n  \n    \n      \n        m\n        ≥\n        n\n      \n    \n    {\\displaystyle m\\geq n}\n  \n. A key \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n is hashed using a hash function \n  \n    \n      \n        h\n      \n    \n    {\\displaystyle h}\n  \n to compute an index location \n  \n    \n      \n        A\n        [\n        h\n        (\n        x\n        )\n        ]\n      \n    \n    {\\displaystyle A[h(x)]}\n  \n in the hash table, where \n  \n    \n      \n        h\n        (\n        x\n        )\n        <\n        m\n      \n    \n    {\\displaystyle h(x)<m}\n  \n. The efficiency of a hash table depends on the load factor, defined as the ratio of the number of stored elements to the number of available slots, with lower load factors generally yielding faster operations. At this index, both the key and its associated value are stored. Storing the key alongside the value ensures that lookups can verify the key at the index to retrieve the correct value, even in the presence of collisions. Under reasonable assumptions, hash tables have better time complexity bounds on search, delete, and insert operations in comparison to self-balancing binary search trees.\nHash tables are also commonly used to implement sets, by omitting the stored value for each key and merely tracking whether the key is present.\n\n\nLoad factor\nA load factor \n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n is a critical statistic of a hash table, and is defined as follows:\n\n  \n    \n      \n        \n          load factor\n        \n         \n        (\n        α\n        )\n        =\n        \n          \n            n\n            m\n          \n        \n        ,\n      \n    \n    {\\displaystyle {\\text{load factor}}\\ (\\alpha )={\\frac {n}{m}},}\n  \n\nwhere\n\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n is the number of entries occupied in the hash table.\n\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n is the number of buckets.\nThe performance of the hash table deteriorates in relation to the load factor \n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n.  In the limit of large \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n and \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n, each bucket statistically has a Poisson distribution with expectation \n  \n    \n      \n        λ\n        =\n        α\n      \n    \n    {\\displaystyle \\lambda =\\alpha }\n  \n for an ideally random hash function.\nThe software typically ensures that the load factor \n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n remains below a certain constant, \n  \n    \n      \n        \n          α\n          \n            max\n          \n        \n      \n    \n    {\\displaystyle \\alpha _{\\max }}\n  \n. This helps maintain good performance. Therefore, a common approach is to resize or \"rehash\" the hash table whenever the load factor \n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n reaches \n  \n    \n      \n        \n          α\n          \n            max\n          \n        \n      \n    \n    {\\displaystyle \\alpha _{\\max }}\n  \n. Similarly the table may also be resized if the load factor drops below \n  \n    \n      \n        \n          α\n          \n            max\n          \n        \n        \n          /\n        \n        4\n      \n    \n    {\\displaystyle \\alpha _{\\max }/4}\n  \n.\n\n\nLoad factor for separate chaining\nWith separate chaining hash tables, each slot of the bucket array stores a pointer to a list or array of data.\nSeparate chaining hash tables suffer gradually declining performance as the load factor grows, and no fixed point beyond which resizing is absolutely needed.\nWith separate chaining, the value of \n  \n    \n      \n        \n          α\n          \n            max\n          \n        \n      \n    \n    {\\displaystyle \\alpha _{\\max }}\n  \n that gives best performance is typically between 1 and 3.\n\n\nLoad factor for open addressing\nWith open addressing, each slot of the bucket array holds exactly one item. Therefore an open-addressed hash table cannot have a load factor greater than 1.\nThe performance of open addressing becomes very bad when the load factor approaches 1.\nTherefore a hash table that uses open addressing must be resized or rehashed if the load factor \n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n approaches 1.\nWith open addressing, acceptable figures of max load factor \n  \n    \n      \n        \n          α\n          \n            max\n          \n        \n      \n    \n    {\\displaystyle \\alpha _{\\max }}\n  \n should range around 0.6 to 0.75.\n\n\nHash function\nA hash function \n  \n    \n      \n        h\n        :\n        U\n        →\n        {\n        0\n        ,\n        .\n        .\n        .\n        ,\n        m\n        −\n        1\n        }\n      \n    \n    {\\displaystyle h:U\\rightarrow \\{0,...,m-1\\}}\n  \n maps the universe \n  \n    \n      \n        U\n      \n    \n    {\\displaystyle U}\n  \n of keys to indices or slots within the table, that is, \n  \n    \n      \n        h\n        (\n        x\n        )\n        ∈\n        {\n        0\n        ,\n        .\n        .\n        .\n        ,\n        m\n        −\n        1\n        }\n      \n    \n    {\\displaystyle h(x)\\in \\{0,...,m-1\\}}\n  \n for \n  \n    \n      \n        x\n        ∈\n        U\n      \n    \n    {\\displaystyle x\\in U}\n  \n. The conventional implementations of hash functions are based on the integer universe assumption that all elements of the table stem from the universe \n  \n    \n      \n        U\n        =\n        {\n        0\n        ,\n        .\n        .\n        .\n        ,\n        u\n        −\n        1\n        }\n      \n    \n    {\\displaystyle U=\\{0,...,u-1\\}}\n  \n, where the bit length of \n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n is confined within the word size of a computer architecture.\nA hash function \n  \n    \n      \n        h\n      \n    \n    {\\displaystyle h}\n  \n is said to be perfect for a given set \n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n if it is injective on \n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n, that is, if each element \n  \n    \n      \n        x\n        ∈\n        S\n      \n    \n    {\\displaystyle x\\in S}\n  \n maps to a different value in \n  \n    \n      \n        \n          0\n          ,\n          .\n          .\n          .\n          ,\n          m\n          −\n          1\n        \n      \n    \n    {\\displaystyle {0,...,m-1}}\n  \n. A perfect hash function can be created if all the keys are known ahead of time.\n\n\nInteger universe assumption\nThe schemes of hashing used in integer universe assumption include hashing by division, hashing by multiplication, universal hashing, dynamic perfect hashing, and static perfect hashing. However, hashing by division is the commonly used scheme.\n\n\nHashing by division\nThe scheme in hashing by division is as follows:\n\n  \n    \n      \n        h\n        (\n        x\n        )\n         \n        =\n         \n        x\n        \n        \n          mod\n          \n            \n          \n        \n        m\n        ,\n      \n    \n    {\\displaystyle h(x)\\ =\\ x\\,{\\bmod {\\,}}m,}\n  \n\nwhere \n  \n    \n      \n        h\n        (\n        x\n        )\n      \n    \n    {\\displaystyle h(x)}\n  \n is the hash value of \n  \n    \n      \n        x\n        ∈\n        S\n      \n    \n    {\\displaystyle x\\in S}\n  \n and \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n is the size of the table.\n\n\nHashing by multiplication\nThe scheme in hashing by multiplication is as follows:\n\n  \n    \n      \n        h\n        (\n        x\n        )\n        =\n        ⌊\n        m\n        \n          \n            (\n          \n        \n        (\n        x\n        A\n        )\n        \n          mod\n          \n            1\n          \n        \n        \n          \n            )\n          \n        \n        ⌋\n      \n    \n    {\\displaystyle h(x)=\\lfloor m{\\bigl (}(xA){\\bmod {1}}{\\bigr )}\\rfloor }\n  \n\nWhere \n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n is a non-integer real-valued constant and \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n is the size of the table. An advantage of the hashing by multiplication is that the \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n is not critical. Although any value \n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n produces a hash function, Donald Knuth suggests using the golden ratio.\n\n\nString hashing\nCommonly a string is used as a key to the hash function.  Stroustrup describes a simple hash function in which an unsigned integer that is initially zero is repeatedly left shifted one bit and then xor'ed with the integer value of the next character.  This hash value is then taken modulo the table size.  If the left shift is not circular, then the string length should be at least eight bits less than the size of the unsigned integer in bits.  Another common way to hash a string to an integer is with a  polynomial rolling hash function.\n\n\nChoosing a hash function\nUniform distribution of the hash values is a fundamental requirement of a hash function. A non-uniform distribution increases the number of collisions and the cost of resolving them. Uniformity is sometimes difficult to ensure by design, but may be evaluated empirically using statistical tests, e.g., a Pearson's chi-squared test for discrete uniform distributions.\nThe distribution needs to be uniform only for table sizes that occur in the application. In particular, if one uses dynamic resizing with exact doubling and halving of the table size, then the hash function needs to be uniform only when the size is a power of two. Here the index can be computed as some range of bits of the hash function. On the other hand, some hashing algorithms prefer to have the size be a prime number.\nFor open addressing schemes, the hash function should also avoid clustering, the mapping of two or more keys to consecutive slots. Such clustering may cause the lookup cost to skyrocket, even if the load factor is low and collisions are infrequent. The popular multiplicative hash is claimed to have particularly poor clustering behavior.\nK-independent hashing offers a way to prove a certain hash function does not have bad keysets for a given type of hashtable. A number of K-independence results are known for collision resolution schemes such as linear probing and cuckoo hashing. Since K-independence can prove a hash function works, one can then focus on finding the fastest possible such hash function.\n\n\nCollision resolution\n\nA search algorithm that uses hashing consists of two parts. The first part is computing a hash function which transforms the search key into an array index. The ideal case is such that no two search keys hash to the same array index. However, this is not always the case and impossible to guarantee for unseen given data. Hence the second part of the algorithm is collision resolution. The two common methods for collision resolution are separate chaining and open addressing.\n\n\nSeparate chaining\n\nIn separate chaining, the process involves building a linked list with key–value pair for each search array index. The collided items are chained together through a single linked list, which can be traversed to access the item with a unique search key. Collision resolution through chaining with linked list is a common method of implementation of hash tables. Let \n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n and \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n be the hash table and the node respectively, the operation involves as follows:\n\nChained-Hash-Insert(T, k)\n  insert x at the head of linked list T[h(k)]\n\nChained-Hash-Search(T, k)\n  search for an element with key k in linked list T[h(k)]\n\nChained-Hash-Delete(T, k)\n  delete x from the linked list T[h(k)]\n\nIf the element is comparable either numerically or lexically, and inserted into the list by maintaining the total order, it results in faster termination of the unsuccessful searches.\n\n\nOther data structures for separate chaining\nIf the keys are ordered, it could be efficient to use \"self-organizing\" concepts such as using a self-balancing binary search tree, through which the theoretical worst case could be brought down to \n  \n    \n      \n        O\n        (\n        log\n        ⁡\n        \n          n\n        \n        )\n      \n    \n    {\\displaystyle O(\\log {n})}\n  \n, although it introduces additional complexities.\nIn dynamic perfect hashing, two-level hash tables are used to reduce the look-up complexity to be a guaranteed \n  \n    \n      \n        O\n        (\n        1\n        )\n      \n    \n    {\\displaystyle O(1)}\n  \n in the worst case. In this technique, the buckets of \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n entries are organized as perfect hash tables with \n  \n    \n      \n        \n          k\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle k^{2}}\n  \n slots providing constant worst-case lookup time, and low amortized time for insertion. A study shows array-based separate chaining to be 97% more performant when compared to the standard linked list method under heavy load.\nTechniques such as using fusion tree for each buckets also result in constant time for all operations with high probability.\n\n\nCaching and locality of reference\nThe linked list of separate chaining implementation may not be cache-conscious due to spatial locality—locality of reference—when the nodes of the linked list are scattered across memory, thus the list traversal during insert and search may entail CPU cache inefficiencies.\nIn cache-conscious variants of collision resolution through separate chaining, a dynamic array found to be more cache-friendly is used in the place where a linked list or self-balancing binary search trees is usually deployed, since the contiguous allocation pattern of  the array could be exploited by hardware-cache prefetchers—such as translation lookaside buffer—resulting in reduced access time and memory consumption.\n\n\nOpen addressing\n\nOpen addressing is another collision resolution technique in which every entry record is stored in the bucket array itself, and the hash resolution is performed through probing. When a new entry has to be inserted, the buckets are examined, starting with the hashed-to slot and proceeding in some probe sequence, until an unoccupied slot is found. When searching for an entry, the buckets are scanned in the same sequence,  until either the target record is found, or an unused array slot is found, which indicates an unsuccessful search.\nWell-known probe sequences include:\n\nLinear probing, in which the interval between probes is fixed (usually 1).\nQuadratic probing, in which the interval between probes is increased by adding the successive outputs of a quadratic polynomial to the value given by the original hash computation.\nDouble hashing, in which the interval between probes is computed by a secondary hash function.\nThe performance of open addressing may be slower compared to separate chaining since the probe sequence increases when the load factor \n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n approaches 1. The probing results in an infinite loop if the load factor reaches 1, in the case of a completely filled table. The average cost of linear probing depends on the hash function's ability to distribute the elements uniformly throughout the table to avoid clustering, since formation of clusters would result in increased search time.\n\n\nCaching and locality of reference\nSince the slots are located in successive locations, linear probing could lead to better utilization of CPU cache due to locality of references resulting in reduced memory latency.\n\n\nOther collision resolution techniques based on open addressing\n\n\nCoalesced hashing\n\nCoalesced hashing is a hybrid of both separate chaining and open addressing in which the buckets or nodes link within the table. The algorithm is ideally suited for fixed memory allocation. The collision in coalesced hashing is resolved by identifying the largest-indexed empty slot on the hash table, then the colliding value is inserted into that slot. The bucket is also linked to the inserted node's slot which contains its colliding hash address.\n\n\nCuckoo hashing\n\nCuckoo hashing is a form of open addressing collision resolution technique which guarantees \n  \n    \n      \n        O\n        (\n        1\n        )\n      \n    \n    {\\displaystyle O(1)}\n  \n worst-case lookup complexity and constant amortized time for insertions. The collision is resolved through maintaining two hash tables, each having its own hashing function, and collided slot gets replaced with the given item, and the preoccupied element of the slot gets displaced into the other hash table. The process continues until every key has its own spot in the empty buckets of the tables; if the procedure enters into infinite loop—which is identified through maintaining a threshold loop counter—both hash tables get rehashed with newer hash functions and the procedure continues.\n\n\nHopscotch hashing\n\nHopscotch hashing is an open addressing based algorithm which combines the elements of cuckoo hashing, linear probing and chaining through the notion of a neighbourhood of buckets—the subsequent buckets around any given occupied bucket, also called a \"virtual\" bucket. The algorithm is designed to deliver better performance when the load factor of the hash table grows beyond 90%; it also provides high throughput in concurrent settings, thus well suited for implementing resizable concurrent hash table. The neighbourhood characteristic of hopscotch hashing guarantees a property that, the cost of finding the desired item from any given buckets within the neighbourhood is very close to the cost of finding it in the bucket itself; the algorithm attempts to be an item into its neighbourhood—with a possible cost involved in displacing other items.\nEach bucket within the hash table includes an additional \"hop-information\"—an H-bit bit array for indicating the relative distance of the item which was originally hashed into the current virtual bucket within H − 1 entries. Let \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n and \n  \n    \n      \n        B\n        k\n      \n    \n    {\\displaystyle Bk}\n  \n be the key to be inserted and bucket to which the key is hashed into respectively; several cases are involved in the insertion procedure such that the neighbourhood property of the algorithm is vowed: if \n  \n    \n      \n        B\n        k\n      \n    \n    {\\displaystyle Bk}\n  \n is empty, the element is inserted, and the leftmost bit of bitmap is set to 1; if not empty, linear probing is used for finding an empty slot in the table, the bitmap of the bucket gets updated followed by the insertion; if the empty slot is not within the range of the neighbourhood, i.e. H − 1, subsequent swap and hop-info bit array manipulation of each bucket is performed in accordance with its neighbourhood invariant properties.\n\n\nRobin Hood hashing\nRobin Hood hashing is an open addressing based collision resolution algorithm; the collisions are resolved through favouring the displacement of the element that is farthest—or longest probe sequence length (PSL)—from its \"home location\" i.e. the bucket to which the item was hashed into. It is named after Robin Hood, a mythical heroic outlaw who stole from the rich to give to the poor.\nAlthough Robin Hood hashing does not change the theoretical search cost, it significantly affects the variance of the distribution of the items on the buckets, i.e. dealing with cluster formation in the hash table. Each node within the hash table that uses Robin Hood hashing should be augmented to store an extra PSL value. Let \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n be the key to be inserted, \n  \n    \n      \n        x\n        \n          .\n        \n        \n          psl\n        \n      \n    \n    {\\displaystyle x{.}{\\text{psl}}}\n  \n be the (incremental) PSL length of \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n, \n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n be the hash table and \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n be the index, the insertion procedure is as follows:\n\nIf \n  \n    \n      \n        x\n        \n          .\n        \n        \n          psl\n        \n         \n        ≤\n         \n        T\n        [\n        j\n        ]\n        \n          .\n        \n        \n          psl\n        \n      \n    \n    {\\displaystyle x{.}{\\text{psl}}\\ \\leq \\ T[j]{.}{\\text{psl}}}\n  \n: the iteration goes into the next bucket without attempting an external probe.\nIf \n  \n    \n      \n        x\n        \n          .\n        \n        \n          psl\n        \n         \n        >\n         \n        T\n        [\n        j\n        ]\n        \n          .\n        \n        \n          psl\n        \n      \n    \n    {\\displaystyle x{.}{\\text{psl}}\\ >\\ T[j]{.}{\\text{psl}}}\n  \n: insert the item \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n into the bucket \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n; swap \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n with \n  \n    \n      \n        T\n        [\n        j\n        ]\n      \n    \n    {\\displaystyle T[j]}\n  \n—let it be \n  \n    \n      \n        \n          x\n          ′\n        \n      \n    \n    {\\displaystyle x'}\n  \n; continue the probe from the \n  \n    \n      \n        (\n        j\n        +\n        1\n        )\n      \n    \n    {\\displaystyle (j+1)}\n  \nth bucket to insert \n  \n    \n      \n        \n          x\n          ′\n        \n      \n    \n    {\\displaystyle x'}\n  \n; repeat the procedure until every element is inserted.\n\n\nDynamic resizing\nRepeated insertions cause the number of entries in a hash table to grow, which consequently increases the load factor; to maintain the amortized \n  \n    \n      \n        O\n        (\n        1\n        )\n      \n    \n    {\\displaystyle O(1)}\n  \n performance of the lookup and insertion operations, a hash table is dynamically resized and the items of the tables are rehashed into the buckets of the new hash table, since the items cannot be copied over as varying table sizes results in different hash value due to modulo operation. If a hash table becomes \"too empty\" after deleting some elements, resizing may be performed to avoid excessive memory usage.\n\n\nResizing by moving all entries\nGenerally, a new hash table with a size double that of the original hash table gets allocated privately and every item in the original hash table gets moved to the newly allocated one by computing the hash values of the items followed by the insertion operation. Rehashing is simple, but computationally expensive.\n\n\nAlternatives to all-at-once rehashing\nSome hash table implementations, notably in real-time systems, cannot pay the price of enlarging the hash table all at once, because it may interrupt time-critical operations. If one cannot avoid dynamic resizing, a solution is to perform the resizing gradually to avoid storage blip—typically at 50% of new table's size—during rehashing and to avoid memory fragmentation that triggers heap compaction due to deallocation of large memory blocks caused by the old hash table. In such case, the rehashing operation is done incrementally through extending prior memory block allocated for the old hash table such that the buckets of the hash table remain unaltered. A common approach for amortized rehashing involves maintaining two hash functions \n  \n    \n      \n        \n          h\n          \n            old\n          \n        \n      \n    \n    {\\displaystyle h_{\\text{old}}}\n  \n and \n  \n    \n      \n        \n          h\n          \n            new\n          \n        \n      \n    \n    {\\displaystyle h_{\\text{new}}}\n  \n. The process of rehashing a bucket's items in accordance with the new hash function is termed as cleaning, which is implemented through command pattern by encapsulating the operations such as \n  \n    \n      \n        \n          A\n          d\n          d\n        \n        (\n        \n          k\n          e\n          y\n        \n        )\n      \n    \n    {\\displaystyle \\mathrm {Add} (\\mathrm {key} )}\n  \n, \n  \n    \n      \n        \n          G\n          e\n          t\n        \n        (\n        \n          k\n          e\n          y\n        \n        )\n      \n    \n    {\\displaystyle \\mathrm {Get} (\\mathrm {key} )}\n  \n and \n  \n    \n      \n        \n          D\n          e\n          l\n          e\n          t\n          e\n        \n        (\n        \n          k\n          e\n          y\n        \n        )\n      \n    \n    {\\displaystyle \\mathrm {Delete} (\\mathrm {key} )}\n  \n through a \n  \n    \n      \n        \n          L\n          o\n          o\n          k\n          u\n          p\n        \n        (\n        \n          k\n          e\n          y\n        \n        ,\n        \n          command\n        \n        )\n      \n    \n    {\\displaystyle \\mathrm {Lookup} (\\mathrm {key} ,{\\text{command}})}\n  \n wrapper such that each element in the bucket gets rehashed and its procedure involve as follows:\n\nClean \n  \n    \n      \n        \n          T\n          a\n          b\n          l\n          e\n        \n        [\n        \n          h\n          \n            old\n          \n        \n        (\n        \n          k\n          e\n          y\n        \n        )\n        ]\n      \n    \n    {\\displaystyle \\mathrm {Table} [h_{\\text{old}}(\\mathrm {key} )]}\n  \n bucket.\nClean \n  \n    \n      \n        \n          T\n          a\n          b\n          l\n          e\n        \n        [\n        \n          h\n          \n            new\n          \n        \n        (\n        \n          k\n          e\n          y\n        \n        )\n        ]\n      \n    \n    {\\displaystyle \\mathrm {Table} [h_{\\text{new}}(\\mathrm {key} )]}\n  \n bucket.\nThe command gets executed.\n\n\nLinear hashing\n\nLinear hashing is an implementation of the hash table which enables dynamic growths or shrinks of the table one bucket at a time.\n\n\nPerformance\nThe performance of a hash table is dependent on the hash function's ability in generating quasi-random numbers (\n  \n    \n      \n        σ\n      \n    \n    {\\displaystyle \\sigma }\n  \n) for entries in the hash table where \n  \n    \n      \n        K\n      \n    \n    {\\displaystyle K}\n  \n, \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n and \n  \n    \n      \n        h\n        (\n        x\n        )\n      \n    \n    {\\displaystyle h(x)}\n  \n denotes the key, number of buckets and the hash function such that \n  \n    \n      \n        σ\n         \n        =\n         \n        h\n        (\n        K\n        )\n         \n        %\n         \n        n\n      \n    \n    {\\displaystyle \\sigma \\ =\\ h(K)\\ \\%\\ n}\n  \n. If the hash function generates the same \n  \n    \n      \n        σ\n      \n    \n    {\\displaystyle \\sigma }\n  \n for distinct keys (\n  \n    \n      \n        \n          K\n          \n            1\n          \n        \n        ≠\n        \n          K\n          \n            2\n          \n        \n        ,\n         \n        h\n        (\n        \n          K\n          \n            1\n          \n        \n        )\n         \n        =\n         \n        h\n        (\n        \n          K\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle K_{1}\\neq K_{2},\\ h(K_{1})\\ =\\ h(K_{2})}\n  \n), this results in collision, which is dealt with in a variety of ways. The constant time complexity (\n  \n    \n      \n        O\n        (\n        1\n        )\n      \n    \n    {\\displaystyle O(1)}\n  \n) of the operation in a hash table is presupposed on the condition that the hash function doesn't generate colliding indices; thus, the performance of the hash table is directly proportional to the chosen hash function's ability to disperse the indices. However, construction of such a hash function is practically infeasible, that being so, implementations depend on case-specific collision resolution techniques in achieving higher performance.\nThe best performance is obtained in the case that the hash function distributes the elements of the universe uniformaly, and the elements stored at the table are drawn at random from the universe. In this case, in hashing with chaining, the expected time for a successful search is \n  \n    \n      \n        1\n        +\n        \n          \n            α\n            2\n          \n        \n        +\n        Θ\n        \n          (\n          \n            \n              1\n              m\n            \n          \n          )\n        \n      \n    \n    {\\textstyle 1+{\\frac {\\alpha }{2}}+\\Theta \\left({\\frac {1}{m}}\\right)}\n  \n, and the expected time for an unsuccessful search is \n  \n    \n      \n        \n          e\n          \n            −\n            α\n          \n        \n        +\n        α\n        +\n        Θ\n        \n          (\n          \n            \n              1\n              m\n            \n          \n          )\n        \n      \n    \n    {\\textstyle e^{-\\alpha }+\\alpha +\\Theta \\left({\\frac {1}{m}}\\right)}\n  \n.\n\n\nApplications\n\n\nAssociative arrays\n\nHash tables are commonly used to implement many types of in-memory tables. They are used to implement associative arrays.\n\n\nDatabase indexing\nHash tables may also be used as disk-based data structures and database indices (such as in dbm) although B-trees are more popular in these applications.\n\n\nCaches\n\nHash tables can be used to implement caches, auxiliary data tables that are used to speed up the access to data that is primarily stored in slower media. In this application, hash collisions can be handled by discarding one of the two colliding entries—usually erasing the old item that is currently stored in the table and overwriting it with the new item, so every item in the table has a unique hash value.\n\n\nSets\n\nHash tables can be used in the implementation of set data structure, which can store unique values without any particular order; set is typically used in testing the membership of a value in the collection, rather than element retrieval.\n\n\nTransposition table\n\nA transposition table to a complex Hash Table which stores information about each section that has been searched.\n\n\nImplementations\nMany programming languages provide hash table functionality, either as built-in associative arrays or as standard library modules.\n\nIn JavaScript, an \"object\" is a mutable collection of key–value pairs (called \"properties\"), where each key is either a string or a guaranteed-unique \"symbol\"; any other value, when used as a key, is first coerced to a string. Aside from the seven \"primitive\" data types, every value in JavaScript is an object. ECMAScript 2015 also added the Map data structure, which accepts arbitrary values as keys.\nC++11 includes unordered_map in its standard library for storing keys and values of arbitrary types.\nGo's built-in map implements a map type in the form of a type, which is often (but not guaranteed to be) a hash table.\nJava programming language includes the HashSet, HashMap, LinkedHashSet, and LinkedHashMap generic collections.\nPython's built-in dict implements a hash table in the form of a type.\nRuby's built-in Hash uses the open addressing model from Ruby 2.4 onwards.\nRust programming language includes HashMap, HashSet as part of the Rust Standard Library.\nThe .NET standard library includes HashSet and Dictionary, so it can be used from languages such as C# and VB.NET.\n\n\nSee also\n\n\nNotes\n\n\nReferences\n\n\nFurther reading\nTamassia, Roberto; Goodrich, Michael T. (2006). \"Chapter Nine: Maps and Dictionaries\". Data structures and algorithms in Java : [updated for Java 5.0] (4th ed.). Hoboken, NJ: Wiley. pp. 369–418. ISBN 978-0-471-73884-8.\nMcKenzie, B. J.; Harries, R.; Bell, T. (February 1990). \"Selecting a hashing algorithm\". Software: Practice and Experience. 20 (2): 209–224. doi:10.1002/spe.4380200207. hdl:10092/9691. S2CID 12854386.\n\n\nExternal links\n\nNIST entry on hash tables\nOpen Data Structures – Chapter 5 – Hash Tables, Pat Morin\nMIT's Introduction to Algorithms: Hashing 1 MIT OCW lecture Video\nMIT's Introduction to Algorithms: Hashing 2 MIT OCW lecture Video",
  "categories": [
    "1953 in computing",
    "Commons category link is locally defined",
    "Hash-based data structures",
    "Short description is different from Wikidata",
    "Use mdy dates from January 2013"
  ],
  "sections": [],
  "source": "wikipedia",
  "sourceUrl": "https://en.wikipedia.org/wiki/Hash_table",
  "scrapedAt": "2026-01-04T05:32:07.032Z",
  "wordCount": 4562
}